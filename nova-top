#!/usr/bin/env python

import cStringIO
import curses
from itertools import count
import locale
import sys

from novaclient import shell

__version__ = "0.2"

instances = {} # master instance list
selected_instance = None # ID of currently selected instance
screen_delay = .1 # seconds between screen updates
update_delay = 2 # seconds between instance list updates
tick = -1 # internal counter incremented in main event loop
title = "nova top"
instructions = """(t)erminate instance | console (o)utput
(q)uit
up(j)/down(k) changes selection
"""
no_instances = "Aww, no instances are running!!"
screen_width = None
scr_fg_colour = curses.COLOR_GREEN
scr_bg_colour = 0
window_fg_colour = curses.COLOR_GREEN
window_bg_colour = 16

conn = None

def move_selection(reverse=False):
    """
    Goes through the list of instances, setting the selected as the one after
    the currently selected.
    """
    global selected_instance
    if selected_instance not in instances:
        selected_instance = None
    found = False
    pids = sorted(instances.keys(), reverse=reverse)
    # Iterate items twice to enable wrapping.
    for pid in pids + pids:
        if selected_instance is None or found:
            selected_instance = pid
            return
        found = pid == selected_instance

def update_instances():
    """
    Updates the dict of instances.
    """

    global instances

    global tick
    tick += 1
    if (tick * screen_delay) % update_delay != 0:
        return
    tick = 0

    results = conn.servers.list()
    instances = {}
    for result in results:
        instances[result.id] = result

def handle_keypress(screen):
    """
    Check for a key being pressed and handle it if applicable.
    """
    global selected_instance
    global selected_instance
    try:
        key = screen.getkey().upper()
    except:
        return
    if key in ("KEY_DOWN", "J"):
        move_selection()
    elif key in ("KEY_UP", "K"):
        move_selection(reverse=True)
    elif key in ("O",):
        if selected_instance in instances:
            instance = conn.servers.get(selected_instance)
            result = instance.get_console_output(1000)
            # FIXME: use a pad and let the user scroll through the output
            y, x = screen.getmaxyx()
            mypad = curses.newpad(1001, x)
            mypad.bkgdset(' ', curses.color_pair(1))
            mypad_pos = 0
            for i, line in enumerate(result.split('\n')):
                mypad.addstr(i, 0, line, curses.A_NORMAL)
            text = "(q) return | (j) scroll up | (k) scroll down"
            screen.addstr(y - 1, 0, text.center(x - 1), curses.A_NORMAL)
            while True:
                mypad.refresh(mypad_pos, 0, 0, 0, y - 2, x - 1)
                try:
                    key = screen.getkey().upper()
                except:
                    continue
                if key in ("KEY_DOWN", "J"):
                    mypad_pos -= 1
                elif key in ("KEY_UP", "K"):
                    mypad_pos += 1
                elif key in ("Q",):
                    break;
    elif key in ("T",):
        if selected_instance in instances:
            instance = conn.servers.get(selected_instance)
            instance.delete()
            tick = 0
            move_selection()
    elif key in ("Q",):
        raise KeyboardInterrupt

def format_row(inst=None):
    """
    Applies consistant padding to each of the columns in a row and serves as
    the source of the overall screen width.
    """
    if inst:
        inst_id = inst.id
        status = inst.status
        ip = inst.addresses.values()[0][0]['addr']
        flavor = inst.flavor['id']
    else:
        inst_id = 'ID'
        status = 'STATUS'
        ip = 'IP'
        flavor = 'FLAVOR'
    row = " %-20.20s %-10.10s %-20.20s %-12.12s " % (inst_id, status,
                                                     ip, flavor)
    global screen_width
    if screen_width is None:
        screen_width = len(row)
    return row

def display_output(screen):
    """
    Display the menu list of instances.
    """
    format_row() # Sets up the screen width.
    screen_height = len(instances) + len(instructions.split("\n")) + 9
    if not instances:
        screen_height += 2 # A couple of blank lines are added when empty.
    screen.erase()
    win = curses.newwin(screen_height, screen_width + 6, 1, 3)
    win.bkgd(" ", curses.color_pair(1))
    win.border()
    x = 3
    blank_line = y = count(2).next
    win.addstr(y(), x, title.center(screen_width), curses.A_NORMAL)
    blank_line()
    win.addstr(y(), x, format_row(), curses.A_STANDOUT)
    if not instances:
        blank_line()
        win.addstr(y(), x, no_instances.center(screen_width), curses.A_NORMAL)
        blank_line()
    else:
        win.hline(y(), x, curses.ACS_HLINE, screen_width)
        for (i, pid) in enumerate(sorted(instances.keys())):
            if pid != selected_instance:
                attr = curses.A_NORMAL
            else:
                attr = curses.A_STANDOUT
            win.addstr(y(), x, format_row(instances[pid]), attr)
    win.hline(y(), x, curses.ACS_HLINE, screen_width)
    blank_line()
    for line in instructions.split("\n"):
        win.addstr(y(), x, line.center(screen_width), curses.A_NORMAL)
    win.refresh()

def main(stdscr):
    """
    Main entry point for nova top.
    """
    try:
        # FIXME(vish): remove this hack to avoid parsing env
        old_stdout = sys.stdout
        sys.stdout = mystdout = cStringIO.StringIO()
        sh = shell.OpenStackComputeShell()
        sh.main(['list'])
        sys.stdout = old_stdout
        global conn
        conn = sh.cs
    except:
        print "environment variables not configured"
        sys.exit(1)

    curses.curs_set(False)
    stdscr.keypad(True)
    stdscr.nodelay(True)
    curses.init_pair(1, window_fg_colour, window_bg_colour)
    curses.init_pair(2, scr_fg_colour, scr_bg_colour)
    stdscr.bkgdset(' ', curses.color_pair(2))
    while True:
        try:
            update_instances()
            handle_keypress(stdscr)
            display_output(stdscr)
            curses.napms(int(screen_delay * 1000))
        except KeyboardInterrupt:
            break

if __name__ == "__main__":
    locale.setlocale(locale.LC_ALL, "")
    curses.wrapper(main)
